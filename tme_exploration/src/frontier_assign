#!/usr/bin/env python3

import numpy as np
import rospy
import re
import actionlib

from scipy.optimize import linear_sum_assignment

from geometry_msgs import Point, Position
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from sensor_msgs.msg import LaserScan

class frontierAssign:
    def __init__(self):
        self.frontiers = []
        self.distances = []
        self.numberRobots = rospy.get_param('/frontier_assign/number_of_robots')
        self.robotPrefix = rospy.get_param('/frontier_assign/robot_ns')
        self.robotPosition = np.empty(self.numberRobots)
        self.robotSpeeds = np.empty(self.numberRobots)
        self.maxSpeed = None
        self.speedModifier = np.empty(self.numberRobots)
        self.visibilityModifier = np.empty(self.numberRobots)
        self.frontierVisibilityModifier = None
        self.frontierDistanceModifier = None

    # Getters for various methods to allow for access in the __main__ part of the class to allow for proper function of the code

    def get_numberRobots(self):
        return self.numberRobots

    def get_robotPrefix(self):
        return self.robotPrefix

    def get_frontierDistance(self):
        return self.distances

    def get_frontierVisibilityModifier(self):
        return self.frontierVisibilityModifier
    
    def get_frontierDistanceModifier(self):
        return self.frontierDistanceModifier

    def get_firstFrontier(self, index):
        return self.frontiers[index][0]

    # Callbacks for the frontiers and position data from the ros topics

    def callback_frontiers(self, data):
        self.frontiers = data

    def callback_position(self, data, topic):
        number = re.search(r'\d+', topic)
        self.robotPosition[number] = data

    # Get euclidean distance between two points
    def euclid_distance(self, a: Point, b: Point):
        result = np.sqrt(np.sum(
            np.square(a.x - b.x),np.square(a.y - b.y)))
        return result

    # Instanciate the self.distances matrix with the distance for every robot to every frontier
    def frontier_distance(self):
        self.distances = np.empty((len(self.frontiers[0]), len(self.robotPosition)))
        for i in self.frontiers[0]:
            for j in self.robotPosition:
                self.distances[i][j] = self.euclid_distance(self.frontiers[i][0], self.robotPosition[j])

    # Get speed for every robot from ros parameters and assign maxSpeed
    def get_robot_speed(self):
        for i in range(0, self.numberRobots):
            temp_str = '/' + self.robotPrefix + str(i+1) + '/max_velocity'
            self.robotSpeeds[i] = rospy.get_param(temp_str)
        self.maxSpeed = np.max(self.robotSpeeds)

    # Assign speed modifiers for every robot by normalizing the values to 0,1 through dividing with the maxSpeed
    def speed_modifier(self):
        self.speedModifier = np.empty(self.numberRobots)
        for i in range(self.numberRobots):
            self.speedModifier[i] = self.robotSpeeds[i]/self.maxSpeed
        
    # Find angle and range of every robot, multiply them and normalize for all values
    def visibility_params(self):
        for i in range(self.numberRobots):
            topic = '/' + self.robotPrefix + str(self.numberRobots) + '/laser_scan'
            data = rospy.wait_for_message(topic, LaserScan)
            overall_angle = data.angle_max - data.angle_min
            overall_range = data.range_max - data.range_min
            self.visibilityModifier[i] = overall_angle * overall_range
        maximum = np.max(self.visibilityModifier)
        self.visiblityModifier = self.visibilityModifier / maximum
    
    # Computes the modifier from robot speed and distance between robot and frontiers, Normalize again
    def frontier_distance_modifier(self):
        for i in range(self.frontiers[0]):
            for j in range(self.numberRobots):
                self.frontierDistanceModifier[i][j] = self.speedModifier[j] * self.distances[i][j]
        self.frontierDistanceModifier = self.frontierDistanceModifier / np.max(self.frontierDistanceModifier)

    # Computes the modifier from robot visibility and size of frontiers, Normalize again
    def frontier_visibility_modifier(self):
        for i in range(self.frontiers[0]):
            for j in range(self.numberRobots):
                self.frontierVisibilityModifier[i][j] = self.visibilityModifier[j] * self.frontiers[i].shape
        self.frontierVisibilityModifier = self.frontierVisibilityModifier / np.max(self.frontierVisibilityModifier)

    # Method to allow the parsing of move_base actions 
    def movebase_client(self, topic, position):
        client = actionlib.SimpleActionClient(topic, MoveBaseAction)

        client.wait_for_server()

        goal = MoveBaseGoal()
        goal.target_pose.header.frame_id = 'map'
        goal.target_pose.header.stamp = rospy.Time.now()
        goal.target_pose.pose.position.x = position[0]
        goal.target_pose.pose.position.y = position[1]
        goal.target_pose.pose.position.z = 0

        client.send_goal(goal)
        wait = client.wait_for_result()
        if not wait:
            rospy.logerr('Action server not available!')
            rospy.signal_shutdown('Action server not available')
        else:
            return client.get_result()

    # minPos approximation by assigning rank based on distance between goal and robot locations
    def rank_matrix(self, matrix):
        result = None
        return result



    if __name__ == '__main__':
        
        rospy.init_node('tme_frontier_assign')

        param_rate = rospy.get_param('/frontier_assign/frontier_rate')
        
        # one of: nearest, greedy, combined, minPos
        chosen_method = rospy.get_param('/frontier_assign/frontier_method')


        subscriber_position = []

        for i in range(get_numberRobots()):
            topic = '/' + get_robotPrefix() + str(get_numberRobots()) + '/position_listener'
            subscriber_position.append = rospy.Subscriber(topic, Position, callback=callback_position, callback_args = topic)

        chosen_method_id = 0

        if(chosen_method == 'nearest'):
            chosen_method_id = 0
        elif(chosen_method == 'greedy'):
            chosen_method_id = 1
        elif(chosen_method == 'combined'):
            chosen_method_id = 2
        else:
            chosen_method_id = 3

        if(chosen_method_id == 2):
            visibility_weighting = rospy.get_param('/frontier_assign/visibility_weighting', 1)
            speed_weighting = rospy.get_param('/frontier_assign/speed_weighting', 1)

        rate = rospy.Rate(param_rate)
        
        while not rospy.is_shutdown():

            cost_matrix = None
            
            if(chosen_method_id == 0):
                frontier_distance()
                cost_matrix = get_frontierDistance()
            
            elif(chosen_method_id == 1):
                frontier_visibility_modifier()
                cost_matrix = get_frontierVisibilityModifier()
            
            elif(chosen_method_id == 2):
                frontier_visibility_modifier()
                frontier_distance()
                frontier_distance_modifier()
                cost_matrix = speed_weighting * get_frontierDistanceModifier() + visibility_weighting * get_frontierVisibilityModifier()
                
            else:
                #TODO
                cost_matrix = rank_matrix()

            assignment = linear_sum_assignment(cost_matrix)

            for i in range(get_numberRobots()):
                topic = '/robot' + str(i) + '/move_base'
                movebase_client(topic=topic, position=get_firstFrontier(index=assignment[i]))

            rate.sleep()