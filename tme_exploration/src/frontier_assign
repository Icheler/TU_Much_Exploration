#!/usr/bin/env python3

import numpy as np
import rospy
import re
import actionlib

from scipy.optimize import linear_sum_assignment

from geometry_msgs.msg import Point, Pose
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from sensor_msgs.msg import LaserScan

class frontierAssign:
    def __init__(self):
        self.frontiers = []
        self.distances = []
        self.numberRobots = rospy.get_param('number_of_robots', 2)
        self.robotPrefix = rospy.get_param('robot_ns', 'robot')
        self.robotPosition = np.empty(self.numberRobots)
        self.robotSpeeds = np.empty(self.numberRobots)
        self.maxSpeed = None
        self.speedModifier = np.empty(self.numberRobots)
        self.visibilityModifier = np.empty(self.numberRobots)
        self.frontierVisibilityModifier = None
        self.frontierDistanceModifier = None

    # Getters for various parameters
    
    def get_numberRobots(self):
        return self.numberRobots

    def get_robotPrefix(self):
        return self.robotPrefix

    def get_frontierDistance(self):
        return self.distances

    def get_frontierVisibilityModifier(self):
        return self.frontierVisibilityModifier
    
    def get_frontierDistanceModifier(self):
        return self.frontierDistanceModifier

    def get_firstFrontier(self, index):
        return self.frontiers[index][0]

    # Callbacks for the frontiers and position data from the ros topics

    def callback_frontiers(self, data):
        self.frontiers = data

    def callback_position(self, data, topic):
        number = re.search(r'\d+', topic)
        self.robotPosition[number] = data

    # Get euclidean distance between two points
    def euclid_distance(self, a: Point, b: Point):
        result = np.sqrt(np.sum(
            np.square(a.x - b.x),np.square(a.y - b.y)))
        return result

    # Instanciate the self.distances matrix with the distance for every robot to every frontier
    def frontier_distance(self):
        self.distances = np.empty((len(self.frontiers[0]), len(self.robotPosition)))
        for i in self.frontiers[0]:
            for j in self.robotPosition:
                self.distances[i][j] = self.euclid_distance(self.frontiers[i][0], self.robotPosition[j])

    # Get speed for every robot from ros parameters and assign maxSpeed
    def get_robot_speed(self):
        for i in range(0, self.numberRobots):
            temp_str = '/' + self.robotPrefix + str(i+1) + '/max_velocity'
            self.robotSpeeds[i] = rospy.get_param(temp_str)
        self.maxSpeed = np.max(self.robotSpeeds)

    # Assign speed modifiers for every robot by normalizing the values to 0,1 through dividing with the maxSpeed
    def speed_modifier(self):
        self.speedModifier = np.empty(self.numberRobots)
        for i in range(self.numberRobots):
            self.speedModifier[i] = self.robotSpeeds[i]/self.maxSpeed
        
    # Find angle and range of every robot, multiply them and normalize for all values
    def visibility_params(self):
        for i in range(self.numberRobots):
            topic = '/' + self.robotPrefix + str(self.numberRobots) + '/laser_scan'
            data = rospy.wait_for_message(topic, LaserScan)
            overall_angle = data.angle_max - data.angle_min
            overall_range = data.range_max - data.range_min
            self.visibilityModifier[i] = overall_angle * overall_range
        maximum = np.max(self.visibilityModifier)
        self.visiblityModifier = self.visibilityModifier / maximum
    
    # Computes the modifier from robot speed and distance between robot and frontiers, Normalize again
    def frontier_distance_modifier(self):
        for i in range(self.frontiers[0]):
            for j in range(self.numberRobots):
                self.frontierDistanceModifier[i][j] = self.speedModifier[j] * self.distances[i][j]
        self.frontierDistanceModifier = self.frontierDistanceModifier / np.max(self.frontierDistanceModifier)

    # Computes the modifier from robot visibility and size of frontiers, Normalize again
    def frontier_visibility_modifier(self):
        for i in range(self.frontiers[0]):
            for j in range(self.numberRobots):
                self.frontierVisibilityModifier[i][j] = self.visibilityModifier[j] * self.frontiers[i].shape
        self.frontierVisibilityModifier = self.frontierVisibilityModifier / np.max(self.frontierVisibilityModifier)

    # Method to allow the parsing of move_base actions 
    def movebase_client(self, topic, position):
        client = actionlib.SimpleActionClient(topic, MoveBaseAction)

        client.wait_for_server()

        goal = MoveBaseGoal()
        goal.target_pose.header.frame_id = 'map'
        goal.target_pose.header.stamp = rospy.Time.now()
        goal.target_pose.pose.position.x = position[0]
        goal.target_pose.pose.position.y = position[1]
        goal.target_pose.pose.position.z = 0

        client.send_goal(goal)
        wait = client.wait_for_result()
        if not wait:
            rospy.logerr('Action server not available!')
            rospy.signal_shutdown('Action server not available')
        else:
            return client.get_result()

    # minPos approximation by assigning rank based on distance between goal and robot locations
    def rank_matrix(self, matrix):
        result = None
        return result


if __name__ == '__main__':
    
    rospy.init_node('frontier_assign')

    param_rate = rospy.get_param('frontier_rate', 5)

    fInstance = frontierAssign()
    
    # one of: nearest, greedy, combined, minPos
    chosen_method = rospy.get_param('frontier_method', "combined")

    subscriber_position = []

    for i in range(fInstance.get_numberRobots()):
        topic = '/' + fInstance.get_robotPrefix() + str(fInstance.get_numberRobots()) + '/position_listener'
        subscriber_position.append(rospy.Subscriber(topic, Point, callback=fInstance.callback_position, callback_args = topic))

    chosen_method_id = 0

    if(chosen_method == 'nearest'):
        chosen_method_id = 0
    elif(chosen_method == 'greedy'):
        chosen_method_id = 1
    elif(chosen_method == 'combined'):
        chosen_method_id = 2
    else:
        chosen_method_id = 3

    if(chosen_method_id == 2):
        visibility_weighting = rospy.get_param('visibility_weighting', 1)
        speed_weighting = rospy.get_param('speed_weighting', 1)

    rate = rospy.Rate(param_rate)
    
    while not rospy.is_shutdown():

        cost_matrix = None
        
        if(chosen_method_id == 0):
            fInstance.frontier_distance()
            cost_matrix = fInstance.get_frontierDistance()
        
        elif(chosen_method_id == 1):
            fInstance.frontier_visibility_modifier()
            cost_matrix = fInstance.get_frontierVisibilityModifier()
        
        elif(chosen_method_id == 2):
            fInstance.frontier_visibility_modifier()
            fInstance.frontier_distance()
            fInstance.frontier_distance_modifier()
            cost_matrix = speed_weighting * fInstance.get_frontierDistanceModifier() + visibility_weighting * fInstance.get_frontierVisibilityModifier()
            
        else:
            #TODO
            cost_matrix = fInstance.rank_matrix()

        assignment = fInstance.linear_sum_assignment(cost_matrix)

        for i in range(fInstance.get_numberRobots()):
            topic = '/robot' + str(i) + '/move_base'
            fInstance.movebase_client(topic=topic, position=fInstance.get_firstFrontier(index=assignment[i]))

        rate.sleep()