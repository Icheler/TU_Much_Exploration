#!/usr/bin/env python3

import numpy as np
import rospy
import re
import actionlib
import tf
import os
import atexit
import random

from scipy.optimize import linear_sum_assignment
from datetime import datetime

from tme_exploration.msg import frontier, frontierArray
from geometry_msgs.msg import Point, Pose, PoseWithCovarianceStamped
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from sensor_msgs.msg import LaserScan
from visualization_msgs.msg import Marker, MarkerArray
from actionlib_msgs.msg import GoalStatusArray


class frontierAssign:
    def __init__(self):
        self.date_string = datetime.now().strftime("%Y-%m-%d|%H:%M:%S")
        self.frontiers = []
        self.distances = []
        self.numberRobots = rospy.get_param('~number_of_robots')
        self.robotPrefix = rospy.get_param('~robot_ns')
        self.robotPosition = np.empty(self.numberRobots, dtype=Point)
        self.robotSpeeds = np.empty(self.numberRobots)
        self.maxSpeed = None
        self.speedModifier = np.empty(self.numberRobots)
        self.visibilityModifier = np.empty(self.numberRobots)
        self.frontierVisibilityModifier = None
        self.frontierDistanceModifier = None
        self.assign_robot_speed()
        self.speed_modifier()
        self.visibility_params()
        self.lastSearchTime = np.empty(self.numberRobots, dtype=rospy.Time)
        self.goals = np.empty(self.numberRobots, dtype=Point)
        self.publisher_position = []
        self.robotMarker = Marker()
        self.searchNow = False
        self.lastPos = np.empty(self.numberRobots, dtype=Point)
        self.travelDistances = []
        self.travelDistancesTotal = np.zeros(self.numberRobots)
        self.chosenMethod = rospy.get_param('~frontier_method')
        self.goalStatus = np.empty(self.numberRobots)
        self.subStatus = []
        self.blacklist = []
        self.explored_frontiers = np.empty(self.numberRobots)
        self.map_name = os.environ['tme_ROBOT_ENV']

        atexit.register(self.exit_handler)

        for i in range(self.numberRobots):
            self.lastSearchTime[i] = rospy.Time.now() - rospy.Duration(30)
            j = i+1
            topic = '/' + self.robotPrefix + str(j) + '/point_relay'
            self.publisher_position.append(rospy.Publisher(topic, Point, queue_size=10))

            topic = '/' + self.robotPrefix + str(j) + '/move_base/status'
            self.subStatus.append(rospy.Subscriber(topic, GoalStatusArray, queue_size=10, callback_args = topic))

        self.robotMarker.header.frame_id = "map"
        #self.robotMarker.header.stamp    = rospy.get_rostime()
        #self.robotMarker.ns = "robot"
        self.robotMarker.id = 0
        self.robotMarker.type = 2 # sphere
        self.robotMarker.action = 0
        #self.robotMarker.pose.position = self.state.point
        self.robotMarker.pose.orientation.x = 0
        self.robotMarker.pose.orientation.y = 0
        self.robotMarker.pose.orientation.z = 0
        self.robotMarker.pose.orientation.w = 1.0
        self.robotMarker.scale.x = 1.0
        self.robotMarker.scale.y = 1.0
        self.robotMarker.scale.z = 1.0

        #self.robotMarker.color.r = 0.0
        #self.robotMarker.color.g = 1.0
        #self.robotMarker.color.b = 0.0
        self.robotMarker.color.a = 1.0

    def exit_handler(self):
        travelDistances = self.travelDistances

        date_string = self.date_string

        file_location = 'catkin_ws/src/TU_Much_Exploration/tme_data/distances'
        file_name = str(self.map_name) + str("_") + str(self.chosenMethod) + str("_") + date_string + ".txt"
        file_name = os.path.join(os.path.expanduser('~'),file_location, file_name)

        a_file = open(file_name, 'w+')
        np.savetxt(a_file, travelDistances)

        a_file.close()

        rospy.logwarn('created file named: ' + file_name)

    # Getters for various parameters

    def set_goals(self, number, value):
        self.goals[number] = value

    def set_searchNow_false(self):
        self.searchNow = False

    def set_chosenMethod(self, method):
        self.chosenMethod = method

    def get_travelDistances(self):
        return self.travelDistances

    def get_searchNow(self):
        return self.searchNow

    def get_robotMarker(self):
        return self.robotMarker

    def get_robotPosition(self, number):
        return self.robotPosition[number]
    
    def get_lastSearchTime(self, number):
        return self.lastSearchTime[number]

    def get_numberRobots(self):
        return self.numberRobots

    def get_robotPrefix(self):
        return self.robotPrefix

    def get_frontierDistance(self):
        return self.distances

    def get_frontierVisibilityModifier(self):
        return self.frontierVisibilityModifier
    
    def get_frontierDistanceModifier(self):
        return self.frontierDistanceModifier

    def get_firstFrontier(self):
        return self.frontiers.frontiers[0]

    def get_frontiers(self):
        return self.frontiers

    def get_goals(self):
        return self.goals

    def get_nap_name(self):
        return self.map_name

    def increment_frontiers(self, number):
        self.explored_frontiers[number] += 1

    # Callbacks for the frontiers and position data from the ros topics

    def callback_frontiers(self, data):
        self.frontiers = data

    def callback_position(self, data, topic):
        number = (int)((re.search(r'\d+', topic)).group(0)) - 1
        robot_location = data.pose.pose.position
        try:
            tf_topic = '/robot' + str(number+1) + '/map'
            (trans, rot) = listener.lookupTransform('/map', tf_topic, rospy.Time(0))

            robot_location.x = robot_location.x + trans[0]
            robot_location.y = robot_location.y + trans[1]
        except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
            pass
        self.robotPosition[number] = robot_location

    def callback_status(self, data, topic):
        number = (int)((re.search(r'\d+', topic)).group(0)) - 1
        status_list = data.status_list

        for i in range(len(status_list)):
            if(status_list[i].status == 4):
                np.append(self.blacklist, self.goals[number])

    def blacklist_check(self):
        foundSth = 0
        localFrontiers = self.frontiers.frontiers
        if(len(localFrontiers) == 0):
            for i in range(len(localFrontiers)):
                foundSth = 0
                x = i - foundSth
                for j in range(len(self.blacklist)):
                    if (localFrontiers[x].centroid == self.blacklist[j]):
                        foundSth += 1
                        localFrontiers.pop(x)
            self.frontiers.frontiers = localFrontiers

    def distance_tracker(self, time_estimate):
        temp_array = [time_estimate]
        not_first = True
        for i in range(self.numberRobots):
            if(self.lastPos[i]):
                self.travelDistancesTotal[i] += self.euclid_distance(self.lastPos[i], self.robotPosition[i])
                temp_array.append(self.travelDistancesTotal[i])
                self.lastPos[i] = self.robotPosition[i]
            else:
                not_first = True
                self.lastPos[i] = self.robotPosition[i]
                temp_array.append(0)
        for i in range(self.numberRobots):
            if(not_first):
                temp_array.append(self.explored_frontiers[i])
            else:
                temp_array.append(0)

        self.travelDistances.append(temp_array)

    # Get euclidean distance between two points
    def euclid_distance(self, a: Point, b: Point):
        testa = np.square(a.x - b.x)
        testb = np.square(a.y - b.y)
        testc = testa + testb
        result = np.sqrt(testc)
        return result

    # Instanciate the self.distances matrix with the distance for every robot to every frontier
    def frontier_distance(self):
        try:
            self.distances = np.empty((len(self.frontiers.frontiers), len(self.robotPosition)))
            for i in range(len(self.frontiers.frontiers)):
                for j in range(len(self.robotPosition)):
                    self.distances[i][j] = self.euclid_distance(self.frontiers.frontiers[i].centroid, self.robotPosition[j])
        except ValueError:
            pass

    # Get speed for every robot from ros parameters and assign maxSpeed
    def assign_robot_speed(self):
        for i in range(0, self.numberRobots):
            temp_str = '/' + self.robotPrefix + str(i+1) + '/max_velocity'
            #TODO
            self.robotSpeeds[i] = 1#rospy.get_param(temp_str)
        self.maxSpeed = np.max(self.robotSpeeds)

    # Assign speed modifiers for every robot by normalizing the values to 0,1 through dividing with the maxSpeed
    def speed_modifier(self):
        self.speedModifier = np.empty(self.numberRobots)
        for i in range(self.numberRobots):
            self.speedModifier[i] = self.robotSpeeds[i]/self.maxSpeed
        
    # Find angle and range of every robot, multiply them and normalize for all values
    def visibility_params(self):
        self.visibilityModifier = np.zeros(self.numberRobots)
        for i in range(self.numberRobots):
            topic = '/' + self.robotPrefix + str(self.numberRobots) + '/scan'
            data = rospy.wait_for_message(topic, LaserScan)
            overall_angle = data.angle_max - data.angle_min
            overall_range = data.range_max - data.range_min
            self.visibilityModifier[i] = overall_angle * overall_range
        maximum = np.max(self.visibilityModifier)
        self.visiblityModifier = self.visibilityModifier / maximum
    
    # Computes the modifier from robot speed and distance between robot and frontiers, Normalize again
    def frontier_distance_modifier(self):
        try:
            self.frontierDistanceModifier = np.ones((len(self.frontiers.frontiers), self.numberRobots))
            for i in range(len(self.frontiers.frontiers)):
                for j in range(self.numberRobots):
                    self.frontierDistanceModifier[i][j] = self.speedModifier[j] * self.distances[i][j]
            self.frontierDistanceModifier = self.frontierDistanceModifier / np.max(self.frontierDistanceModifier)
        except ValueError:
            pass

    # Computes the modifier from robot visibility and size of frontiers, Normalize again
    def frontier_visibility_modifier(self):
        try:
            self.frontierVisibilityModifier = np.ones((len(self.frontiers.frontiers), self.numberRobots))
            for i in range(len(self.frontiers.frontiers)):
                for j in range(self.numberRobots):
                    self.frontierVisibilityModifier[i][j] = self.visibilityModifier[j] * self.frontiers.frontiers[i].size
            self.frontierVisibilityModifier = self.frontierVisibilityModifier / np.max(self.frontierVisibilityModifier)
            self.frontierVisibilityModifier = 1 - self.frontierVisibilityModifier

        except ValueError:
            pass

    def active_cb(self):
        rospy.loginfo("Goal pose is now being processed by the Action Server...")

    def feedback_cb(self, feedback):
        rospy.loginfo("Feedback for goal pose received")

    def done_cb(self, status, result):
    # Reference for terminal status values: http://docs.ros.org/diamondback/api/actcombinedionlib_msgs/html/msg/GoalStatus.html
        rospy.logwarn("move_base exited with status: " + str(status))
        
        if status == 2:
            rospy.loginfo("Goal pose received a cancel request after it started executing, completed execution!")

        if status == 3:
            rospy.loginfo("Goal pose reached")
            #self.lastSearchTime = rospy.Time.now()

        if status == 4:
            rospy.loginfo("Goal pose was aborted by the Action Server")
            return

        if status == 5:
            rospy.loginfo("Goal pose has been rejected by the Action Server")
            return

        if status == 8:
            rospy.loginfo("Goal pose received a cancel request before it started executing, successfully cancelled!")

    # Method to allow the parsing of move_base actions 
    def movebase_client(self, topic, number, position, delete=False):

        client = actionlib.SimpleActionClient(topic, MoveBaseAction)

        client.wait_for_server()

        goal = MoveBaseGoal()
        goal.target_pose.header.frame_id = 'map'
        goal.target_pose.header.stamp = rospy.Time.now()
        goal.target_pose.pose.position.x = position.x
        goal.target_pose.pose.position.y = position.y
        goal.target_pose.pose.position.z = 0
        goal.target_pose.pose.orientation.w = 1

        self.lastSearchTime[number] = rospy.Time.now()

        client.send_goal(goal, self.done_cb, self.active_cb, self.feedback_cb)

    def movebase_spoof(self, number, position):
        self.lastSearchTime = rospy.Time.now()
        self.publisher_position[number].publish(position)

    # minPos approximation by assigning rank based on distance between goal and robot locations
    def rank_matrix(self):
        self.frontier_distance()
        self.frontier_distance_modifier()
        order = np.argsort(self.frontierDistanceModifier, axis=1)
        ranks = np.argsort(order, axis=1)
        return ranks #+ 0.01 * self.frontierDistanceModifier


if __name__ == '__main__':
    
    rospy.init_node('frontier_assign')

    param_rate = rospy.get_param('~frontier_rate', 5)

    data = rospy.wait_for_message('/tme_frontier_search/frontierArray', frontierArray)

    fInstance = frontierAssign()

    listener = tf.TransformListener()

    markerPub = rospy.Publisher('robotMarker', Marker, queue_size=10)
    
    # one of: nearest, greedy, combined, minPos
    chosen_method = rospy.get_param('~frontier_method')
    rospy.logwarn("Method is set to find {} goal".format(chosen_method))
    fInstance.set_chosenMethod(chosen_method)

    rospy.Subscriber("/tme_frontier_search/frontierArray", frontierArray, fInstance.callback_frontiers)
    subscriber_position = []

    for i in range(fInstance.get_numberRobots()):
        j = i+1
        topic = '/' + fInstance.get_robotPrefix() + str(j) + '/poseupdate'
        subscriber_position.append(rospy.Subscriber(topic, PoseWithCovarianceStamped, callback=fInstance.callback_position, callback_args = topic))

    chosen_method_id = 0

    if(chosen_method == 'nearest'):
        chosen_method_id = 0
    elif(chosen_method == 'greedy'):
        chosen_method_id = 1
    elif(chosen_method == 'minPos'):
        chosen_method_id = 2
    else:
        chosen_method_id = 3
        visibility_weighting = rospy.get_param('~visibility_weighting', 1)
        speed_weighting = rospy.get_param('~speed_weighting', 1)

    rate = rospy.Rate(param_rate)
    id = 0

    time_estimate = 0
    time_increment = 1
    
    while not rospy.is_shutdown():

        cost_matrix = None
        
        if(fInstance.frontiers):
            fInstance.blacklist_check()
            if(chosen_method_id == 0):
                fInstance.frontier_distance()
                cost_matrix = fInstance.get_frontierDistance()
            
            elif(chosen_method_id == 1):
                fInstance.frontier_visibility_modifier()
                fInstance.frontier_distance()
                cost_matrix = fInstance.get_frontierVisibilityModifier() + fInstance.get_frontierDistance() * 0.01
            
            elif(chosen_method_id == 2):
                #TODO
                cost_matrix = fInstance.rank_matrix()
            else:
                fInstance.frontier_visibility_modifier()
                fInstance.frontier_distance()
                fInstance.frontier_distance_modifier()
                cost_matrix = speed_weighting * fInstance.get_frontierDistanceModifier() + visibility_weighting * fInstance.get_frontierVisibilityModifier()
            
            cost_matrix = np.transpose(cost_matrix)
            row_ind, col_ind = linear_sum_assignment(cost_matrix)

            for i in range(fInstance.get_numberRobots()):
                j = i+1
                topic = '/robot' + str(j) + '/move_base'
                temp_frontiers = fInstance.frontiers.frontiers
                if(len(temp_frontiers) <= fInstance.get_numberRobots()):
                    if(j > len(temp_frontiers)):
                        break 
                
                temp_assignment = temp_frontiers[col_ind[i]]
                goal_location = temp_assignment.centroid

                goals = fInstance.get_goals()
                #fInstance.set_goals(i, goal_location)
                #fInstance.movebase_spoof(topic=topic, position=goal_location)
                #fInstance.movebase_spoof(number=i, position=goal_location)

                if(fInstance.get_lastSearchTime(i) + rospy.Duration(secs=5)< rospy.Time.now()):
                    if(goal_location != goals[i]):
                        fInstance.set_goals(i, goal_location)
                        fInstance.movebase_client(topic=topic, number=i, position=goal_location)
                        marker = fInstance.get_robotMarker()
                        marker.header.stamp = rospy.Time.now()
                        marker.ns = 'beep'
                        id += 1
                        marker.id = id
                        marker.pose.position = goal_location
                        if(i == 0):
                            marker.color.r = 0
                            marker.color.g = 0
                            marker.color.b = 0
                        else:
                            marker.color.r = 1
                            marker.color.g = 1
                            marker.color.b = 1
                        marker.lifetime = rospy.Duration(5)

                        markerPub.publish(marker)
                        #fInstance.movebase_spoof(number=i, position=goal_location)
                        fInstance.increment_frontiers(i)
                    elif(fInstance.get_lastSearchTime(i) + rospy.Duration(secs=10)< rospy.Time.now()):
                        goal_location.x += random.uniform(-0.2, 0.2)
                        goal_location.y += random.uniform(-0.2, 0.2)
                        fInstance.set_goals(i, goal_location)
                        fInstance.movebase_client(topic=topic, number=i, position=goal_location, delete=True)
                        marker = fInstance.get_robotMarker()
                        marker.header.stamp = rospy.Time.now()
                        marker.ns = 'beep'
                        id += 1
                        marker.id = id
                        marker.pose.position = goal_location
                        if(i == 0):
                            marker.color.r = 0
                            marker.color.g = 0
                            marker.color.b = 0
                        else:
                            marker.color.r = 1
                            marker.color.g = 1
                            marker.color.b = 1
                        marker.lifetime = rospy.Duration(20)

                        markerPub.publish(marker)

                        #fInstance.movebase_spoof(number=i, position=goal_location)

                markerPub.publish(marker)

        else:
            rospy.logwarn("frontiers is empty")

        rate.sleep()

        if(time_estimate % 25 == 0 or time_estimate == 0):
            time_estimate = int(time_estimate)
            temp_estimate = int(time_estimate / 5)
            fInstance.distance_tracker(temp_estimate)

        time_estimate += time_increment



