#!/usr/bin/env python3

import numpy as np
import rospy
import re
import actionlib

from scipy.optimize import linear_sum_assignment

from tme_exploration.msg import frontier, frontierArray
from geometry_msgs.msg import Point, Pose, PoseWithCovarianceStamped
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from sensor_msgs.msg import LaserScan


class frontierAssign:
    def __init__(self):
        self.frontiers = []
        self.distances = []
        self.numberRobots = rospy.get_param('number_of_robots', 2)
        self.robotPrefix = rospy.get_param('robot_ns', 'robot')
        self.robotPosition = np.empty(self.numberRobots, dtype=Point)
        self.robotSpeeds = np.empty(self.numberRobots)
        self.maxSpeed = None
        self.speedModifier = np.empty(self.numberRobots)
        self.visibilityModifier = np.empty(self.numberRobots)
        self.frontierVisibilityModifier = None
        self.frontierDistanceModifier = None
        self.assign_robot_speed()
        self.speed_modifier()
        self.visibility_params()
        self.lastSearchTime = rospy.Time.now() - rospy.Duration(30)
        self.goals = np.empty(self.numberRobots, dtype=Point)
        self.publisher_position = []

        for i in range(self.numberRobots):
            j = i+1
            topic = '/' + self.robotPrefix + str(j) + '/point_relay'
            self.publisher_position.append(rospy.Publisher(topic, Point, queue_size=10))

    # Getters for various parameters

    def set_goals(self, number, value):
        self.goals[number] = value
    
    def get_lastSearchTime(self):
        return self.lastSearchTime

    def get_numberRobots(self):
        return self.numberRobots

    def get_robotPrefix(self):
        return self.robotPrefix

    def get_frontierDistance(self):
        return self.distances

    def get_frontierVisibilityModifier(self):
        return self.frontierVisibilityModifier
    
    def get_frontierDistanceModifier(self):
        return self.frontierDistanceModifier

    def get_firstFrontier(self):
        return self.frontiers.frontiers[0]

    def get_frontiers(self):
        return self.frontiers

    def get_goals(self):
        return self.goals

    # Callbacks for the frontiers and position data from the ros topics

    def callback_frontiers(self, data):
        self.frontiers = data

    def callback_position(self, data, topic):
        number = (int)((re.search(r'\d+', topic)).group(0)) - 1
        self.robotPosition[number] = data.pose.pose.position #data.pose.pose.position

    # Get euclidean distance between two points
    def euclid_distance(self, a: Point, b: Point):
        testa = np.square(a.x - b.x)
        testb = np.square(a.y - b.y)
        testc = testa + testb
        result = np.sqrt(testc)
        return result

    # Instanciate the self.distances matrix with the distance for every robot to every frontier
    def frontier_distance(self):
        try:
            self.distances = np.empty((len(self.frontiers.frontiers), len(self.robotPosition)))
            for i in range(len(self.frontiers.frontiers)):
                for j in range(len(self.robotPosition)):
                    self.distances[i][j] = self.euclid_distance(self.frontiers.frontiers[i].initial, self.robotPosition[j])
        except ValueError:
            pass

    # Get speed for every robot from ros parameters and assign maxSpeed
    def assign_robot_speed(self):
        for i in range(0, self.numberRobots):
            temp_str = '/' + self.robotPrefix + str(i+1) + '/max_velocity'
            #TODO
            self.robotSpeeds[i] = 1#rospy.get_param(temp_str)
        self.maxSpeed = np.max(self.robotSpeeds)

    # Assign speed modifiers for every robot by normalizing the values to 0,1 through dividing with the maxSpeed
    def speed_modifier(self):
        self.speedModifier = np.empty(self.numberRobots)
        for i in range(self.numberRobots):
            self.speedModifier[i] = self.robotSpeeds[i]/self.maxSpeed
        
    # Find angle and range of every robot, multiply them and normalize for all values
    def visibility_params(self):
        self.visibilityModifier = np.zeros(self.numberRobots)
        for i in range(self.numberRobots):
            topic = '/' + self.robotPrefix + str(self.numberRobots) + '/scan'
            data = rospy.wait_for_message(topic, LaserScan)
            overall_angle = data.angle_max - data.angle_min
            overall_range = data.range_max - data.range_min
            self.visibilityModifier[i] = overall_angle * overall_range
        maximum = np.max(self.visibilityModifier)
        self.visiblityModifier = self.visibilityModifier / maximum
    
    # Computes the modifier from robot speed and distance between robot and frontiers, Normalize again
    def frontier_distance_modifier(self):
        try:
            self.frontierDistanceModifier = np.ones((len(self.frontiers.frontiers), self.numberRobots))
            for i in range(len(self.frontiers.frontiers)):
                for j in range(self.numberRobots):
                    self.frontierDistanceModifier[i][j] = self.speedModifier[j] * self.distances[i][j]
            self.frontierDistanceModifier = self.frontierDistanceModifier / np.max(self.frontierDistanceModifier)
        except ValueError:
            pass

    # Computes the modifier from robot visibility and size of frontiers, Normalize again
    def frontier_visibility_modifier(self):
        try:
            self.frontierVisibilityModifier = np.ones((len(self.frontiers.frontiers), self.numberRobots))
            for i in range(len(self.frontiers.frontiers)):
                for j in range(self.numberRobots):
                    self.frontierVisibilityModifier[i][j] = self.visibilityModifier[j] * self.frontiers.frontiers[i].size
            self.frontierVisibilityModifier = self.frontierVisibilityModifier / np.max(self.frontierVisibilityModifier)
        except ValueError:
            pass

    def active_cb(self):
        rospy.loginfo("Goal pose is now being processed by the Action Server...")

    def feedback_cb(self, feedback):
        rospy.loginfo("Feedback for goal pose received")

    def done_cb(self, status, result):
    # Reference for terminal status values: http://docs.ros.org/diamondback/api/actcombinedionlib_msgs/html/msg/GoalStatus.html
        rospy.logwarn("move_base exited with status: " + str(status))
        
        if status == 2:
            rospy.loginfo("Goal pose received a cancel request after it started executing, completed execution!")

        if status == 3:
            rospy.loginfo("Goal pose reached")
            self.lastSearchTime = rospy.Time.now()

        if status == 4:
            rospy.loginfo("Goal pose was aborted by the Action Server")
            rospy.signal_shutdown("Goal pose aborted, shutting down!")
            return

        if status == 5:
            rospy.loginfo("Goal pose has been rejected by the Action Server")
            rospy.signal_shutdown("Goal pose rejected, shutting down!")
            return

        if status == 8:
            rospy.loginfo("Goal pose received a cancel request before it started executing, successfully cancelled!")

    # Method to allow the parsing of move_base actions 
    def movebase_client(self, topic, position):

        client = actionlib.SimpleActionClient(topic, MoveBaseAction)

        client.wait_for_server()

        goal = MoveBaseGoal()
        goal.target_pose.header.frame_id = 'map'
        goal.target_pose.header.stamp = rospy.Time.now()
        goal.target_pose.pose.position.x = position.x
        goal.target_pose.pose.position.y = position.y
        goal.target_pose.pose.position.z = 0
        goal.target_pose.pose.orientation.w = 1

        client.cancel_all_goals()
        client.wait_for_result()
        client.send_goal(goal, self.done_cb, self.active_cb, self.feedback_cb)

    def movebase_spoof(self, number, position):
        self.publisher_position[number].publish(position)

    # minPos approximation by assigning rank based on distance between goal and robot locations
    def rank_matrix(self, matrix):
        result = None
        return result


if __name__ == '__main__':
    
    rospy.init_node('frontier_assign')

    param_rate = rospy.get_param('frontier_rate', 2)

    data = rospy.wait_for_message('/tme_frontier_search/frontierArray', frontierArray)

    fInstance = frontierAssign()
    
    # one of: nearest, greedy, combined, minPos
    chosen_method = rospy.get_param('frontier_method', "combined")

    rospy.Subscriber("/tme_frontier_search/frontierArray", frontierArray, fInstance.callback_frontiers)
    subscriber_position = []

    for i in range(fInstance.get_numberRobots()):
        j = i+1
        topic = '/' + fInstance.get_robotPrefix() + str(j) + '/poseupdate'
        subscriber_position.append(rospy.Subscriber(topic, PoseWithCovarianceStamped, callback=fInstance.callback_position, callback_args = topic))

    chosen_method_id = 0

    if(chosen_method == 'nearest'):
        chosen_method_id = 0
    elif(chosen_method == 'greedy'):
        chosen_method_id = 1
    elif(chosen_method == 'minPos'):
        chosen_method_id = 2
    else:
        chosen_method_id = 3
        visibility_weighting = rospy.get_param('visibility_weighting', 1)
        speed_weighting = rospy.get_param('speed_weighting', 1)

    rate = rospy.Rate(param_rate)
    
    while not rospy.is_shutdown():

        cost_matrix = None
        
        if(fInstance.frontiers):
            if(chosen_method_id == 0):
                fInstance.frontier_distance()
                cost_matrix = fInstance.get_frontierDistance()
            
            elif(chosen_method_id == 1):
                fInstance.frontier_visibility_modifier()
                cost_matrix = fInstance.get_frontierVisibilityModifier()
            
            elif(chosen_method_id == 2):
                #TODO
                cost_matrix = fInstance.rank_matrix()
                
            else:
                fInstance.frontier_visibility_modifier()
                fInstance.frontier_distance()
                fInstance.frontier_distance_modifier()
                cost_matrix = speed_weighting * fInstance.get_frontierDistanceModifier() + visibility_weighting * fInstance.get_frontierVisibilityModifier()
                
            
            assignment = linear_sum_assignment(cost_matrix)

            for i in range(fInstance.get_numberRobots()):
                j = i+1
                topic = '/robot' + str(j) + '/move_base'
                temp_frontiers = fInstance.get_frontiers()
                temp_assignment = temp_frontiers.frontiers[assignment[0][i]]
                goals = fInstance.get_goals()
                fInstance.set_goals(i, temp_assignment.centroid)
                #fInstance.movebase_spoof(topic=topic, position=temp_assignment.centroid)
                #fInstance.movebase_spoof(number=i, position=temp_assignment.centroid)
                if(fInstance.get_lastSearchTime() + rospy.Duration(secs=5)< rospy.Time.now()):
                    if(temp_assignment.centroid != goals[i]):
                        fInstance.set_goals(i, temp_assignment.centroid)
                        #fInstance.movebase_client(topic=topic, position=temp_assignment.centroid)
                        fInstance.movebase_spoof(number=i, position=temp_assignment.initial)
                    if(fInstance.get_lastSearchTime() + rospy.Duration(secs=30)< rospy.Time.now()):
                        fInstance.set_goals(i, temp_assignment.centroid)
                        #fInstance.movebase_client(topic=topic, position=temp_assignment.centroid)
                        fInstance.movebase_spoof(number=i, position=temp_assignment.initial)

        else:
            rospy.logwarn("frontiers is empty")

        rate.sleep()